# 真正的广度优先算法

深度优先对应的是栈,有回溯的过程,
而广度优先没有回溯的过程(他是先处理完一层再去子层)
广度优先对应着queue(队列)
即将当前节点的相邻节点放进队尾
暂存之(也导致了内存的成本)
而接着处理队首(是和上一个节点同一层的)

我之前写的那个版本的类BFS的深度优先算法的问题是不能保证一个节点的值统一(只存了第一次到的值,如果后续有更快的路就没法存了)
而现在保证一层一层的搜,搜全了

## 关于路的长度

以起点为0,每一次把子节点入队时,写入父节点值+1

**写值的两个地方**
1.单独开一个vis数组,同时起到控制访问的作用,这样不损害原图
2,破坏原图,直接把可行节点的值写成dis